# üèõÔ∏è –°–∏—Å—Ç–µ–º–∞ –ë–∞–π—Ç–∫–æ–¥–∞ –∏ VM –¥–ª—è SOFIA

### –í–≤–µ–¥–µ–Ω–∏–µ

–î–∞–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –±–∞–π—Ç–∫–æ–¥–∞ –∏ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤–æ–π –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π –º–∞—à–∏–Ω—ã (VM) –¥–ª—è —è–∑—ã–∫–∞ SOFIA. –¶–µ–ª—å—é —è–≤–ª—è–µ—Ç—Å—è –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ –ø–æ–≤—ã—à–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–¥–∞ (–æ—Ä–∏–µ–Ω—Ç–∏—Ä X10) –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø–æ–ª–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Å–µ–º–∞–Ω—Ç–∏–∫–æ–π —è–∑—ã–∫–∞ –∏ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ–º —Ä–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç–∏, –æ—Ç–ª–∞–∂–∏–≤–∞–µ–º–æ—Å—Ç–∏ –∏ –º–æ–¥—É–ª—å–Ω–æ—Å—Ç–∏. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–∞ —Å —É—á–µ—Ç–æ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π, –∏ –∑–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç –¥–ª—è –±—É–¥—É—â–∏—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π, —Ç–∞–∫–∏—Ö –∫–∞–∫ JIT-–∫–æ–º–ø–∏–ª—è—Ü–∏—è.

### –û–±–∑–æ—Ä –æ–±—â–µ–π —Å—Ö–µ–º—ã –ø–∞–π–ø–ª–∞–π–Ω–∞

–°—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–∞–π–ø–ª–∞–π–Ω –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è SOFIA –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ AST-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏. –ù–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –≤–≤–æ–¥–∏—Ç —ç—Ç–∞–ø –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ AST –≤ –±–∞–π—Ç–∫–æ–¥ –∏ –µ–≥–æ –ø–æ—Å–ª–µ–¥—É—é—â–µ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤–æ–π VM.

**–ü–∞–π–ø–ª–∞–π–Ω –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è:**

1.  **–ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥**
2.  **–õ–µ–∫—Å–µ—Ä** ([`../src/lexer.rs`](../src/lexer.rs)): –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –≤ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–æ–≤.
3.  **–ü–∞—Ä—Å–µ—Ä** ([`../src/parser.rs`](../src/parser.rs)): –°—Ç—Ä–æ–∏—Ç –ê–±—Å—Ç—Ä–∞–∫—Ç–Ω–æ–µ –°–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–µ –î–µ—Ä–µ–≤–æ (AST) –∏–∑ —Ç–æ–∫–µ–Ω–æ–≤.
4.  **–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä** ([`../src/compiler.rs`](../src/compiler.rs)): –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç AST –≤ –±–∞–π—Ç–∫–æ–¥ (`Instructions`).
5.  **–í–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –º–∞—à–∏–Ω–∞** ([`../src/vm/mod.rs`](../src/vm/mod.rs)): –ò—Å–ø–æ–ª–Ω—è–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∞–π—Ç–∫–æ–¥.
6.  **–†–µ–∑—É–ª—å—Ç–∞—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è**

**–ú–µ—Ö–∞–Ω–∏–∑–º –≤—ã–±–æ—Ä–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è:**
–í —Ç–æ—á–∫–µ –≤—Ö–æ–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã ([`../src/main.rs`](../src/main.rs)) –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –º–µ—Ö–∞–Ω–∏–∑–º –≤—ã–±–æ—Ä–∞ –º–µ–∂–¥—É AST-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–æ–º –∏ –Ω–æ–≤–æ–π VM. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è VM. AST-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä ([`../src/evaluator.rs`](../src/evaluator.rs)) —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏. –í—ã–±–æ—Ä –º–æ–∂–µ—Ç –æ—Å—É—â–µ—Å—Ç–≤–ª—è—Ç—å—Å—è —á–µ—Ä–µ–∑ —Ñ–ª–∞–≥ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `--vm` –∏–ª–∏ `--ast`).

```mermaid
graph TD
    A[–ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥] --> B(–õ–µ–∫—Å–µ—Ä ../src/lexer.rs);
    B --> C(–ü–∞—Ä—Å–µ—Ä ../src/parser.rs);
    C --> D{AST ../src/ast.rs};

    subgraph –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
        direction LR
        D -- "–í—ã–±–æ—Ä –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è –≤ main.rs" --> E{–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä ../src/compiler.rs};
        D -- "Fallback" --> F(AST-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä ../src/evaluator.rs);
        E --> G{–ë–∞–π—Ç–∫–æ–¥ ../src/bytecode/instructions.rs};
        G -- "–û–ø–∫–æ–¥—ã ../src/bytecode/opcode.rs" --> G;
        G --> H(–í–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –º–∞—à–∏–Ω–∞ ../src/vm/mod.rs);
        H -- "–û–±—ä–µ–∫—Ç–Ω–∞—è –º–æ–¥–µ–ª—å ../src/object.rs" --> H;
        H --> I[–†–µ–∑—É–ª—å—Ç–∞—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è];
        F --> I;
    end

    subgraph –û—Ç–ª–∞–¥–∫–∞
        G --> J(–î–∏–∑–∞—Å—Å–µ–º–±–ª–µ—Ä ../src/bytecode/disassembler.rs);
        H --> K(–¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ VM);
        J --> L[–ß–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º—ã–π –±–∞–π—Ç–∫–æ–¥];
        K --> M[–°–æ—Å—Ç–æ—è–Ω–∏–µ VM –∏ AST-—Å–≤—è–∑–∏];
    end
```

### –î–µ—Ç–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–æ–¥—É–ª–µ–π –∏ –∏—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤

#### –ú–æ–¥—É–ª—å `../src/bytecode/`

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–ª—è –æ–ø–∫–æ–¥–æ–≤ –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, —Ö—Ä–∞–Ω—è—â–µ–π –±–∞–π—Ç–∫–æ–¥.

- **`../src/bytecode/mod.rs`**: –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è –º–æ–¥—É–ª—è –±–∞–π—Ç–∫–æ–¥–∞, —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É—é—â–∞—è `opcode` –∏ `instructions`.

  ```rust
  // ../src/bytecode/mod.rs
  pub mod opcode;
  pub mod instructions;
  ```

- **`../src/bytecode/opcode.rs`**: –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ `Opcode` –¥–ª—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π VM.

  ```rust
  // ../src/bytecode/opcode.rs
  #[derive(Debug, PartialEq, Clone, Copy)]
  pub enum Opcode {
      // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
      Constant, // –ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É –∏–∑ –ø—É–ª–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã.

      // –ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –∏ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
      Add,      // –°–ª–æ–∂–µ–Ω–∏–µ
      Sub,      // –í—ã—á–∏—Ç–∞–Ω–∏–µ
      Mul,      // –£–º–Ω–æ–∂–µ–Ω–∏–µ
      Div,      // –î–µ–ª–µ–Ω–∏–µ
      Mod,      // –ú–æ–¥—É–ª—å
      Pow,      // –í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å
      Neg,      // –£–Ω–∞—Ä–Ω—ã–π –º–∏–Ω—É—Å
      Not,      // –õ–æ–≥–∏—á–µ—Å–∫–æ–µ –ù–ï
      And,      // –õ–æ–≥–∏—á–µ—Å–∫–æ–µ –ò
      Or,       // –õ–æ–≥–∏—á–µ—Å–∫–æ–µ –ò–õ–ò

      // –°—Ä–∞–≤–Ω–µ–Ω–∏—è
      Equal,    // –†–∞–≤–Ω–æ
      NotEqual, // –ù–µ —Ä–∞–≤–Ω–æ
      GreaterThan, // –ë–æ–ª—å—à–µ —á–µ–º
      LessThan, // –ú–µ–Ω—å—à–µ —á–µ–º

      // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º
      Jump,     // –ë–µ–∑—É—Å–ª–æ–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥. –û–ø–µ—Ä–∞–Ω–¥: —Å–º–µ—â–µ–Ω–∏–µ.
      JumpIfFalse, // –ü–µ—Ä–µ—Ö–æ–¥, –µ—Å–ª–∏ –≤–µ—Ä—à–∏–Ω–∞ —Å—Ç–µ–∫–∞ false. –û–ø–µ—Ä–∞–Ω–¥: —Å–º–µ—â–µ–Ω–∏–µ.
      Call,     // –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏. –û–ø–µ—Ä–∞–Ω–¥: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤.
      Return,   // –í–æ–∑–≤—Ä–∞—Ç –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏.

      // –†–∞–±–æ—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏
      GetGlobal, // –ü–æ–ª—É—á–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –∏–º–µ–Ω–∏ –≤ –ø—É–ª–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç.
      SetGlobal, // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –∏–º–µ–Ω–∏ –≤ –ø—É–ª–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç.
      GetLocal,  // –ü–æ–ª—É—á–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.
      SetLocal,  // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.

      // –†–∞–±–æ—Ç–∞ —Å–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö
      Array,    // –°–æ–∑–¥–∞—Ç—å –º–∞—Å—Å–∏–≤. –û–ø–µ—Ä–∞–Ω–¥: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
      Hash,     // –°–æ–∑–¥–∞—Ç—å —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—É (–æ–±—ä–µ–∫—Ç). –û–ø–µ—Ä–∞–Ω–¥: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ.
      Index,    // –î–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É (–¥–ª—è –º–∞—Å—Å–∏–≤–æ–≤ –∏ —Ö—ç—à–µ–π).

      // –ö–ª–∞—Å—Å—ã –∏ –æ–±—ä–µ–∫—Ç—ã
      Class,    // –û–±—ä—è–≤–∏—Ç—å –∫–ª–∞—Å—Å. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –∏–º–µ–Ω–∏ –∫–ª–∞—Å—Å–∞ –≤ –ø—É–ª–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç.
      GetProperty, // –ü–æ–ª—É—á–∏—Ç—å —Å–≤–æ–π—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–∞. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –∏–º–µ–Ω–∏ —Å–≤–æ–π—Å—Ç–≤–∞ –≤ –ø—É–ª–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç.
      SetProperty, // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–≤–æ–π—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–∞. –û–ø–µ—Ä–∞–Ω–¥: –∏–Ω–¥–µ–∫—Å –∏–º–µ–Ω–∏ —Å–≤–æ–π—Å—Ç–≤–∞ –≤ –ø—É–ª–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç.
      New,      // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∞—Å—Å–∞/—Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –û–ø–µ—Ä–∞–Ω–¥: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞.
      This,     // –ó–∞–≥—Ä—É–∑–∏—Ç—å 'this'.
      Super,    // –ó–∞–≥—Ä—É–∑–∏—Ç—å 'super'.

      // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ
      Pop,      // –£–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å –≤–µ—Ä—à–∏–Ω—ã —Å—Ç–µ–∫–∞.
      Null,     // –ó–∞–≥—Ä—É–∑–∏—Ç—å null.
      True,     // –ó–∞–≥—Ä—É–∑–∏—Ç—å true.
      False,    // –ó–∞–≥—Ä—É–∑–∏—Ç—å false.
      NoOp,     // –ù–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏ (–¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –∏–ª–∏ –æ—Ç–ª–∞–¥–∫–∏).
      MapToAst, // –°–≤—è–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π –æ–ø–∫–æ–¥ —Å —É–∑–ª–æ–º AST (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏). –û–ø–µ—Ä–∞–Ω–¥: ID —É–∑–ª–∞ AST.
  }

  impl Opcode {
      pub fn to_string(&self) -> &'static str {
          match self {
              Opcode::Constant => "CONSTANT",
              Opcode::Add => "ADD",
              Opcode::Sub => "SUB",
              Opcode::Mul => "MUL",
              Opcode::Div => "DIV",
              Opcode::Mod => "MOD",
              Opcode::Pow => "POW",
              Opcode::Neg => "NEG",
              Opcode::Not => "NOT",
              Opcode::And => "AND",
              Opcode::Or => "OR",
              Opcode::Equal => "EQUAL",
              Opcode::NotEqual => "NOT_EQUAL",
              Opcode::GreaterThan => "GREATER_THAN",
              Opcode::LessThan => "LESS_THAN",
              Opcode::Jump => "JUMP",
              Opcode::JumpIfFalse => "JUMP_IF_FALSE",
              Opcode::Call => "CALL",
              Opcode::Return => "RETURN",
              Opcode::GetGlobal => "GET_GLOBAL",
              Opcode::SetGlobal => "SET_GLOBAL",
              Opcode::GetLocal => "GET_LOCAL",
              Opcode::SetLocal => "SET_LOCAL",
              Opcode::Array => "ARRAY",
              Opcode::Hash => "HASH",
              Opcode::Index => "INDEX",
              Opcode::Class => "CLASS",
              Opcode::GetProperty => "GET_PROPERTY",
              Opcode::SetProperty => "SET_PROPERTY",
              Opcode::New => "NEW",
              Opcode::This => "THIS",
              Opcode::Super => "SUPER",
              Opcode::Pop => "POP",
              Opcode::Null => "NULL",
              Opcode::True => "TRUE",
              Opcode::False => "FALSE",
              Opcode::NoOp => "NO_OP",
              Opcode::MapToAst => "MAP_TO_AST",
          }
      }

      pub fn operand_count(&self) -> usize {
          match self {
              Opcode::Constant
              | Opcode::Jump
              | Opcode::JumpIfFalse
              | Opcode::Call
              | Opcode::GetGlobal
              | Opcode::SetGlobal
              | Opcode::GetLocal
              | Opcode::SetLocal
              | Opcode::Array
              | Opcode::Hash
              | Opcode::Class
              | Opcode::GetProperty
              | Opcode::SetProperty
              | Opcode::New
              | Opcode::MapToAst => 1,
              Opcode::Add | Opcode::Sub | Opcode::Mul | Opcode::Div | Opcode::Mod | Opcode::Pow
              | Opcode::Equal | Opcode::NotEqual | Opcode::GreaterThan | Opcode::LessThan
              | Opcode::And | Opcode::Or
              | Opcode::Index => 0,
              Opcode::Neg | Opcode::Not | Opcode::Return | Opcode::Pop | Opcode::Null
              | Opcode::True | Opcode::False | Opcode::This | Opcode::Super | Opcode::NoOp => 0,
          }
      }
  }
  ```

- **`../src/bytecode/instructions.rs`**: –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –±–∞–π—Ç–∫–æ–¥–∞ –∏ –ø—É–ª–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç.

  ```rust
  // ../src/bytecode/instructions.rs
  use crate::object::Object;
  use crate::bytecode::opcode::Opcode;

  #[derive(Debug, PartialEq, Clone)]
  pub struct Instructions {
      pub bytes: Vec<u8>,
      pub constants: Vec<Object>, // –ü—É–ª –∫–æ–Ω—Å—Ç–∞–Ω—Ç
  }

  impl Instructions {
      pub fn new() -> Self {
          Instructions {
              bytes: Vec::new(),
              constants: Vec::new(),
          }
      }

      pub fn emit(&mut self, op: Opcode, operands: &[usize]) -> usize {
          let pos = self.bytes.len();
          self.bytes.push(op as u8);

          for &operand in operands {
              if operand > u8::MAX as usize {
                  self.bytes.push((operand >> 8) as u8);
                  self.bytes.push(operand as u8);
              } else {
                  self.bytes.push(operand as u8);
              }
          }
          pos
      }

      pub fn add_constant(&mut self, obj: Object) -> usize {
          self.constants.push(obj);
          self.constants.len() - 1
      }

      pub fn get_opcode(&self, offset: usize) -> Option<Opcode> {
          if offset < self.bytes.len() {
              Some(unsafe { std::mem::transmute::<u8, Opcode>(self.bytes[offset]) })
          } else {
              None
          }
      }

      pub fn get_operand(&self, offset: usize, size: usize) -> Option<usize> {
          if offset + size <= self.bytes.len() {
              let mut operand = 0;
              for i in 0..size {
                  operand = (operand << 8) | (self.bytes[offset + i] as usize);
              }
              Some(operand)
          } else {
              None
          }
      }
  }
  ```

#### –ú–æ–¥—É–ª—å `../src/vm/`

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤–æ–π –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π –º–∞—à–∏–Ω—ã.

- **`../src/vm/mod.rs`**: –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ VM –∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ç–∏–ø—ã.

  ```rust
  // ../src/vm/mod.rs
  use crate::bytecode::instructions::Instructions;
  use crate::object::Object;
  use std::collections::HashMap;
  use std::rc::Rc;
  use std::cell::RefCell;

  const STACK_SIZE: usize = 2048;
  const NUM_REGISTERS: usize = 16;

  pub struct VM {
      pub instructions: Instructions,
      pub stack: Vec<Object>,
      pub sp: usize,
      pub registers: Vec<Object>,
      pub ip: usize,
      pub frames: Vec<CallFrame>,
      pub globals: Rc<RefCell<HashMap<String, Object>>>,
      pub current_frame_index: usize,
  }

  impl VM {
      pub fn new(instructions: Instructions) -> Self {
          VM {
              instructions,
              stack: vec![Object::Null; STACK_SIZE],
              sp: 0,
              registers: vec![Object::Null; NUM_REGISTERS],
              ip: 0,
              frames: Vec::new(),
              globals: Rc::new(RefCell::new(HashMap::new())),
              current_frame_index: 0,
          }
      }

      pub fn run(&mut self) -> Result<Object, String> {
          // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –æ—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ü–∏–∫–ª–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–π—Ç–∫–æ–¥–∞
          // ...
          Ok(Object::Null)
      }

      fn push(&mut self, obj: Object) -> Result<(), String> {
          if self.sp >= STACK_SIZE {
              return Err("Stack overflow".to_string());
          }
          self.stack.insert(self.sp, obj);
          self.sp += 1;
          Ok(())
      }

      fn pop(&mut self) -> Result<Object, String> {
          if self.sp == 0 {
              return Err("Stack underflow".to_string());
          }
          self.sp -= 1;
          Ok(self.stack.remove(self.sp))
      }
  }

  #[derive(Debug, PartialEq, Clone)]
  pub struct CallFrame {
      // pub function: Rc<CompiledFunction>,
      pub return_addr: usize,
      pub base_pointer: usize,
      pub num_locals: usize,
      // pub registers_snapshot: Vec<Object>,
  }

  #[derive(Debug, PartialEq, Clone)]
  pub struct CompiledFunction {
      pub instructions_offset: usize,
      pub num_locals: usize,
      pub num_parameters: usize,
  }
  ```

#### –ú–æ–¥—É–ª—å `../src/compiler.rs`

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é AST –≤ –±–∞–π—Ç–∫–æ–¥.

- **`../src/compiler.rs`**:

  ```rust
  // ../src/compiler.rs
  use crate::ast::{Program, Statement, Expression};
  use crate::bytecode::instructions::Instructions;
  use crate::bytecode::opcode::Opcode;
  use crate::object::Object;

  #[derive(Debug)]
  pub enum CompilerError {
      UnknownOperator(String),
      // ... –¥—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
  }

  pub struct Compiler {
      instructions: Instructions,
      // ... —Ç–∞–±–ª–∏—Ü—ã —Å–∏–º–≤–æ–ª–æ–≤, —Å—á–µ—Ç—á–∏–∫–∏ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
  }

  impl Compiler {
      pub fn new() -> Self {
          Compiler {
              instructions: Instructions::new(),
          }
      }

      pub fn compile_program(&mut self, program: Program) -> Result<Instructions, CompilerError> {
          for statement in program.statements {
              self.compile_statement(statement)?;
          }
          Ok(std::mem::take(&mut self.instructions))
      }

      fn compile_statement(&mut self, statement: Statement) -> Result<(), CompilerError> {
          match statement {
              Statement::Expression(expr_stmt) => {
                  self.compile_expression(expr_stmt.expression)?;
                  self.instructions.emit(Opcode::Pop, &[]);
              },
              Statement::Let(let_stmt) => {
                  self.compile_expression(let_stmt.value)?;
                  self.instructions.emit(Opcode::SetGlobal, &[0]);
              },
              Statement::Return(ret_stmt) => {
                  self.compile_expression(ret_stmt.return_value)?;
                  self.instructions.emit(Opcode::Return, &[]);
              },
              // ... –¥—Ä—É–≥–∏–µ —Ç–∏–ø—ã –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
              _ => unimplemented!(),
          }
          Ok(())
      }

      fn compile_expression(&mut self, expression: Expression) -> Result<(), CompilerError> {
          match expression {
              Expression::IntegerLiteral(il) => {
                  let constant_index = self.instructions.add_constant(Object::Integer(il.value));
                  self.instructions.emit(Opcode::Constant, &[constant_index]);
              },
              Expression::Boolean(b) => {
                  if b.value {
                      self.instructions.emit(Opcode::True, &[]);
                  } else {
                      self.instructions.emit(Opcode::False, &[]);
                  }
              },
              Expression::Prefix(pe) => {
                  self.compile_expression(*pe.right)?;
                  match pe.operator.as_str() {
                      "!" => self.instructions.emit(Opcode::Not, &[]),
                      "-" => self.instructions.emit(Opcode::Neg, &[]),
                      _ => return Err(CompilerError::UnknownOperator(pe.operator)),
                  };
              },
              Expression::Infix(ie) => {
                  self.compile_expression(*ie.left)?;
                  self.compile_expression(*ie.right)?;
                  match ie.operator.as_str() {
                      "+" => self.instructions.emit(Opcode::Add, &[]),
                      "-" => self.instructions.emit(Opcode::Sub, &[]),
                      "*" => self.instructions.emit(Opcode::Mul, &[]),
                      "/" => self.instructions.emit(Opcode::Div, &[]),
                      "%" => self.instructions.emit(Opcode::Mod, &[]),
                      "**" => self.instructions.emit(Opcode::Pow, &[]),
                      "==" => self.instructions.emit(Opcode::Equal, &[]),
                      "!=" => self.instructions.emit(Opcode::NotEqual, &[]),
                      ">" => self.instructions.emit(Opcode::GreaterThan, &[]),
                      "<" => self.instructions.emit(Opcode::LessThan, &[]),
                      "&&" => self.instructions.emit(Opcode::And, &[]),
                      "||" => self.instructions.emit(Opcode::Or, &[]),
                      _ => return Err(CompilerError::UnknownOperator(ie.operator)),
                  };
              },
              // ... –¥—Ä—É–≥–∏–µ —Ç–∏–ø—ã –≤—ã—Ä–∞–∂–µ–Ω–∏–π
              _ => unimplemented!(),
          }
          Ok(())
      }
  }
  ```

#### –ú–æ–¥—É–ª—å `../src/bytecode/disassembler.rs`

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –±–∞–π—Ç–∫–æ–¥–∞ –≤ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç.

- **`../src/bytecode/disassembler.rs`**:

  ```rust
  // ../src/bytecode/disassembler.rs
  use crate::bytecode::instructions::Instructions;
  use crate::bytecode::opcode::Opcode;

  pub fn disassemble(instructions: &Instructions) -> String {
      let mut output = String::new();
      let mut offset = 0;
      while offset < instructions.bytes.len() {
          let op = instructions.get_opcode(offset).expect("Invalid opcode");
          output.push_str(&format!("{:04} {}\n", offset, op.to_string()));
          offset += 1;

          let operand_count = op.operand_count();
          for i in 0..operand_count {
              let operand_value = instructions.get_operand(offset, 1).expect("Missing operand");
              output.push_str(&format!("       Operand {}: {}\n", i, operand_value));
              offset += 1;
          }
      }
      output
  }
  ```

### –ü–µ—Ä–µ—á–µ–Ω—å –æ–ø–∫–æ–¥–æ–≤ —Å –∫—Ä–∞—Ç–∫–∏–º –æ–ø–∏—Å–∞–Ω–∏–µ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è

–ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –æ–ø–∫–æ–¥–æ–≤ –∏ –∏—Ö –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ [`../src/bytecode/opcode.rs`](../src/bytecode/opcode.rs). –û–Ω–∏ –ø–æ–∫—Ä—ã–≤–∞—é—Ç:

- **–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã:** `Constant`
- **–ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –∏ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:** `Add`, `Sub`, `Mul`, `Div`, `Mod`, `Pow`, `Neg`, `Not`, `And`, `Or`
- **–°—Ä–∞–≤–Ω–µ–Ω–∏—è:** `Equal`, `NotEqual`, `GreaterThan`, `LessThan`
- **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º:** `Jump`, `JumpIfFalse`, `Call`, `Return`
- **–†–∞–±–æ—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏:** `GetGlobal`, `SetGlobal`, `GetLocal`, `SetLocal`
- **–†–∞–±–æ—Ç–∞ —Å–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö:** `Array`, `Hash`, `Index`
- **–ö–ª–∞—Å—Å—ã –∏ –æ–±—ä–µ–∫—Ç—ã:** `Class`, `GetProperty`, `SetProperty`, `New`, `This`, `Super`
- **–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ:** `Pop`, `Null`, `True`, `False`, `NoOp`, `MapToAst`

### –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ AST ‚Üí bytecode

–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä (`../src/compiler.rs`) –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –æ–±—Ö–æ–¥ AST, –≥–µ–Ω–µ—Ä–∏—Ä—É—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–∞–π—Ç–∫–æ–¥–∞.

- **–í—ã—Ä–∞–∂–µ–Ω–∏—è:**
  - –õ–∏—Ç–µ—Ä–∞–ª—ã: –ø–æ–º–µ—â–∞—é—Ç—Å—è –≤ –ø—É–ª –∫–æ–Ω—Å—Ç–∞–Ω—Ç, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è `Constant`.
  - –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã: `GetGlobal`/`GetLocal`.
  - –ü—Ä–µ—Ñ–∏–∫—Å–Ω—ã–µ/–∏–Ω—Ñ–∏–∫—Å–Ω—ã–µ: –∫–æ–º–ø–∏–ª—è—Ü–∏—è –æ–ø–µ—Ä–∞–Ω–¥–æ–≤, –∑–∞—Ç–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –æ–ø–∫–æ–¥.
  - –í—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π: –∫–æ–º–ø–∏–ª—è—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –∑–∞—Ç–µ–º `Call`.
  - –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤: –∫–æ–º–ø–∏–ª—è—Ü–∏—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –∑–∞—Ç–µ–º `New`.
  - –î–æ—Å—Ç—É–ø –∫ —Å–≤–æ–π—Å—Ç–≤–∞–º: –∫–æ–º–ø–∏–ª—è—Ü–∏—è –æ–±—ä–µ–∫—Ç–∞, –∑–∞—Ç–µ–º `GetProperty`.
  - `this`, `super`: —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –æ–ø–∫–æ–¥—ã.
- **–û–ø–µ—Ä–∞—Ç–æ—Ä—ã:**
  - `LetStatement`: –∫–æ–º–ø–∏–ª—è—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏—è, –∑–∞—Ç–µ–º `SetGlobal`/`SetLocal`.
  - `ReturnStatement`: –∫–æ–º–ø–∏–ª—è—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏—è, –∑–∞—Ç–µ–º `Return`.
  - `ExpressionStatement`: –∫–æ–º–ø–∏–ª—è—Ü–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –∑–∞—Ç–µ–º `Pop`.
  - `BlockStatement`: –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤.
- **–§—É–Ω–∫—Ü–∏–∏ –∏ –∑–∞–º—ã–∫–∞–Ω–∏—è:**
  - –¢–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –±–ª–æ–∫ –±–∞–π—Ç–∫–æ–¥–∞.
  - –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ —Ñ—Ä–µ–π–º—ã –≤—ã–∑–æ–≤–∞.
  - –ó–∞–º—ã–∫–∞–Ω–∏—è —Ç—Ä–µ–±—É—é—Ç –∞–Ω–∞–ª–∏–∑–∞ —Å–≤–æ–±–æ–¥–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –∏—Ö –∑–∞—Ö–≤–∞—Ç–∞.
- **–ö–ª–∞—Å—Å—ã, –º–µ—Ç–æ–¥—ã, —Å–≤–æ–π—Å—Ç–≤–∞:**
  - –ö–ª–∞—Å—Å—ã –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤ –æ–±—ä–µ–∫—Ç—ã `Class` —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏.
  - –°–≤–æ–π—Å—Ç–≤–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è, –º–µ—Ç–æ–¥—ã –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤ `CompiledFunction`.
  - –î–æ—Å—Ç—É–ø –∫ —á–ª–µ–Ω–∞–º —á–µ—Ä–µ–∑ `GetProperty`/`SetProperty`.
- **`match`, `if/else`:**
  - –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –æ–ø–∫–æ–¥—ã —É—Å–ª–æ–≤–Ω—ã—Ö –∏ –±–µ–∑—É—Å–ª–æ–≤–Ω—ã—Ö –ø–µ—Ä–µ—Ö–æ–¥–æ–≤ (`Jump`, `JumpIfFalse`) –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Ç–æ–∫–æ–º.
  - `match` —Ç—Ä–µ–±—É–µ—Ç —Å–ª–æ–∂–Ω–æ–π –ª–æ–≥–∏–∫–∏ –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–∞—Ä–¥–æ–≤.

**–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å–µ–º–∞–Ω—Ç–∏–∫–µ:** –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç —Å—Ç—Ä–æ–≥–æ —Å–ª–µ–¥–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞–º —è–∑—ã–∫–∞ SOFIA, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º –≤ `docs/*.md` –∏ –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º [`../src/evaluator.rs`](../src/evaluator.rs), —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–¥–µ–Ω—Ç–∏—á–Ω—É—é —Å–µ–º–∞–Ω—Ç–∏–∫—É.

### –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏ –æ—Ç–ª–∞–¥–∫–∞

- **–î–∏–∑–∞—Å—Å–µ–º–±–ª–µ—Ä:** –ú–æ–¥—É–ª—å [`../src/bytecode/disassembler.rs`](../src/bytecode/disassembler.rs) –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é `disassemble`, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç `Instructions` –≤ —á–∏—Ç–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç, –æ—Ç–æ–±—Ä–∞–∂–∞—è –æ–ø–∫–æ–¥—ã, –∏—Ö –æ–ø–µ—Ä–∞–Ω–¥—ã –∏ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç.
- **–ü–æ—à–∞–≥–æ–≤–∞—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞:** VM –±—É–¥–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å "—Ä–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏" (`debug_mode`), –≤ –∫–æ—Ç–æ—Ä–æ–º –ø–µ—Ä–µ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º –∫–∞–∂–¥–æ–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –±—É–¥–µ—Ç –≤—ã–≤–æ–¥–∏—Ç—å—Å—è —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ VM (IP, —Ç–µ–∫—É—â–∏–π –æ–ø–∫–æ–¥, —Å—Ç–µ–∫, —Ä–µ–≥–∏—Å—Ç—Ä—ã, —Ñ—Ä–µ–π–º—ã).
- **–¢—Ä–∞—Å—Å–∏—Ä—É–µ–º–æ—Å—Ç—å opcodes ‚Üî AST-—É–∑–ª—ã:** –û–ø–∫–æ–¥ `MapToAst` –±—É–¥–µ—Ç –≤—Å—Ç–∞–≤–ª—è—Ç—å—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º –≤ –±–∞–π—Ç–∫–æ–¥, —Å–≤—è–∑—ã–≤–∞—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º —É–∑–ª–æ–º AST. –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –æ—Ç–ª–∞–¥—á–∏–∫—É –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–µ–∫—É—â–µ–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ VM.

### –†–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç—å –ø–æ–¥ JIT

- **–ë–∞–π—Ç–∫–æ–¥ –∫–∞–∫ IR:** `Opcode` –∏ `Instructions` —è–≤–ª—è—é—Ç—Å—è —á–∏—Å—Ç—ã–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º, –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–º –æ—Ç –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è.
- **–°—Ç–∞–±–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç:** –§–æ—Ä–º–∞—Ç –±–∞–π—Ç–∫–æ–¥–∞ –±—É–¥–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å—Å—è —Å—Ç–∞–±–∏–ª—å–Ω—ã–º, —á—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç JIT-–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –Ω–∞–¥–µ–∂–Ω–æ –µ–≥–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å.
- **–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ:** –ë–∞–π—Ç–∫–æ–¥ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –æ —Ç–∏–ø–∞—Ö –∏ –æ–±–ª–∞—Å—Ç—è—Ö –≤–∏–¥–∏–º–æ—Å—Ç–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è JIT-–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π.
- **–•—É–∫–∏:** VM –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è JIT-—Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≤–µ—Ä—Å–∏–π —Ñ—É–Ω–∫—Ü–∏–π –∏ –ø–µ—Ä–µ–¥–∞—á–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–º.
- **–ú–æ–¥—É–ª—å–Ω–æ—Å—Ç—å:** JIT-–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–º –º–æ–¥—É–ª–µ–º, –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É—é—â–∏–º —Å `Instructions` –∏ VM —á–µ—Ä–µ–∑ —á–µ—Ç–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã.

### –ú–∞—Ç—Ä–∏—Ü–∞ —Ç—Ä–∞—Å—Å–∏—Ä—É–µ–º–æ—Å—Ç–∏

- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: –ú–æ–¥–µ–ª—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è - –†–µ–≥–∏—Å—Ç—Ä–æ–≤–∞—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –º–∞—à–∏–Ω–∞ (VM).**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** –ú–æ–¥—É–ª—å [`../src/vm/mod.rs`](../src/vm/mod.rs) (—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ VM —Å —Ä–µ–≥–∏—Å—Ç—Ä–∞–º–∏, IP, FP, —Å—Ç–µ–∫–æ–º –≤—ã–∑–æ–≤–æ–≤), [`../src/bytecode/opcode.rs`](../src/bytecode/opcode.rs) (–æ–ø–∫–æ–¥—ã –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤–æ–π –º–æ–¥–µ–ª–∏).
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: –û–±—ä–µ–º –º–∏–≥—Ä–∞—Ü–∏–∏ - –í–µ—Å—å —è–∑—ã–∫.**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** –ü–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä –æ–ø–∫–æ–¥–æ–≤ –≤ [`../src/bytecode/opcode.rs`](../src/bytecode/opcode.rs), [`../src/compiler.rs`](../src/compiler.rs) (–ª–æ–≥–∏–∫–∞ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏ –≤—Å–µ—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π), –ø—Ä–∏–Ω—Ü–∏–ø—ã —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏ (—à–∞–≥–∏ 16-20).
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: AST-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ fallback.**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** –ú–µ—Ö–∞–Ω–∏–∑–º –≤—ã–±–æ—Ä–∞ –≤ [`../src/main.rs`](../src/main.rs), —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ [`../src/evaluator.rs`](../src/evaluator.rs).
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å - –ê–±—Å–æ–ª—é—Ç–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å–µ–º–∞–Ω—Ç–∏–∫–∏, –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç—å.**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** –ü—Ä–∏–Ω—Ü–∏–ø—ã —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏ (—à–∞–≥–∏ 16-20), –º–µ—Ö–∞–Ω–∏–∑–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è VM (—à–∞–≥ 15), [`../src/compiler.rs`](../src/compiler.rs) (–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –ø–æ–≤–µ–¥–µ–Ω–∏—è AST).
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å - –¶–µ–ª—å X10.**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–∫–æ–¥–∞ –∏ VM, —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç VM, —Ä–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç—å –ø–æ–¥ JIT (—à–∞–≥ 24).
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: –û—Ç–ª–∞–¥–∫–∞ - –î–∏–∑–∞—Å—Å–µ–º–±–ª–µ—Ä, –ø–æ—à–∞–≥–æ–≤—ã–π —Ä–µ–∂–∏–º, —Ç—Ä–∞—Å—Å–∏—Ä—É–µ–º–æ—Å—Ç—å opcodes ‚Üî AST-—É–∑–ª—ã.**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** [`../src/bytecode/disassembler.rs`](../src/bytecode/disassembler.rs) (—à–∞–≥ 22), –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø–æ—à–∞–≥–æ–≤–æ–π —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ VM (—à–∞–≥ 23), –æ–ø–∫–æ–¥ `MapToAst`.
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è —Ñ–æ—Ä–º–∞ - –û—Ç–¥–µ–ª—å–Ω—ã–µ –º–æ–¥—É–ª–∏ `bytecode/`, `vm/`, —Ä–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç—å –ø–æ–¥ JIT.**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª–µ–π (—à–∞–≥–∏ 3, 5, 6, 7), –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ –¥–ª—è JIT (—à–∞–≥ 24), —á–µ—Ç–∫–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å–ª–æ–µ–≤ (—à–∞–≥ 25).
- **–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: MVP - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ–≥–æ —è–∑—ã–∫–∞.**
  - **–≠–ª–µ–º–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:** –ü–æ–ª–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ —è–∑—ã–∫–∞ –æ–ø–∫–æ–¥–∞–º–∏ (—à–∞–≥ 11) –∏ –ø—Ä–∏–Ω—Ü–∏–ø–∞–º–∏ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏ (—à–∞–≥–∏ 16-20)
